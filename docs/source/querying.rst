Querying the Database
======================

This chapter discusses how the database contents generated by Joern
can be queried to locate interesting code. We begin by reviewing the
basics of the graph traversal language Gremlin and proceed to discuss
how to select start nodes from the node index. The remainder of this
chapter deals with code retrieval based on syntaxtaint-style queries
in and finally, traversals in the function symbol  graph.

The user-defined traversals presented throughout this chapter are all
located in the directory ``joernsteps`` of ``python-joern``. It may be
worth studying their implementation to understand how to design your
own custom steps for Gremlin.

Gremlin Basics
---------------
In this section, we will give a brief overview of the most basic
functionality offered by the graph traversal language Gremlin
developed by Marko A. Rodriguez. For detailed documentation of
language features, please refer to http://gremlindocs.com and the
`Gremlin website <https://github.com/tinkerpop/gremlin/wiki>`_. 

Gremlin is a language designed to describe walks in property graphs. A
property graph is simply a graph where key-value pairs can be attached
to nodes and edges. (From a programmatic point of view, you can simply
think of it as a graph that has hash tables attached to nodes and
edges.) In addition, each edge has a type, and that's all you need to
know about property graphs for now.

Graph traversals proceed in two steps to uncover to search a database
for sub-graphs of interest:


1. **Start node selection.** All traversals begin by selecting a set of
nodes from the database that serve as starting points for walks in the
graph. 

2. **Walking the graph.** Starting at the nodes selected in the
previous step, the traversal walks along the graph edges to reach
adjacent nodes according to properties and types of nodes and
edges. The final goal of the traversal is to determine all nodes that
can be reached by the traversal. You can think of a graph traversal as
a sub-graph description that must be fulfilled in order for a node to
be returned.

The simplest way to select start nodes is to perform a lookup based on
the unique node id as in the following query:

.. code-block:: none

	// Lookup node with given nodeId
	g.v(nodeId)

Walking the graph can now be achieved by attaching so called
\emph{Gremlin steps} to the start node. Each of these steps processes
all nodes returned by the previous step, similar to the way Unix
pipelines connect shell programs. While learning Gremlin, it can thus
be a good idea to think of the dot-operator as an alias for the unix
pipe operator ``\code{|}''. The following is a list of examples.

.. code-block:: none

	// Traverse to nodes connected to start node by outgoing edges
	g.v(nodeId).out()

	// Traverse to nodes two hops away.
	g.v(nodeId).out().out()

	// Traverse to nodes connected to start node by incoming edges
	g.v(nodeId).in()

	// All nodes connected by outgoing AST edges (filtering based
	// on edge types)
	g.v(nodeId).out(AST_EDGE)

	// Filtering based on properties:
	g.v(nodeId).out().filter{ it.type == typeOfInterest}

	// Filtering based on edge properties
	g.v.outE(AST_EDGE).filter{ it.propKey == propValue }.inV()

The last two examples deserve some explanation as they both employ the
elementary step ``filter`` defined by the language Gremlin. ``filter``
expects a so called *closure*, an anonymous function wrapped in curly
brackets (see `Groovy - Closures
<http://groovy.codehaus.org/Closures>`_). This function is applied to
each incoming node and is expected to return ``true`` or ``false`` to
indicate whether the node should pass the filter operation or not. The
first parameter given to a closure is named ``it`` by convention and
thus ``it.type`` denotes the property ``type`` of the incoming node in
the first of the two examples. In the second example, edges are handed
to the filter routine and thus ``it.propKey`` refers to the property
``propKey`` of the incoming edge.

